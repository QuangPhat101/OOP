#  PROOF OF CONCEPT & PROJECT PROPOSAL

## 1. THÔNG TIN 

**Đề tài**: Chatbot Hỗ Trợ Học Lập Trình bằng C++ thông qua Ollama (GPT-OSS:20B)  
**Thời gian thực hiện:** 6 tuần (từ 18/11/2025 đến 18/12/2025)   
**Người thực hiện:** Nguyễn Quang Phát  
**MSSV:** 24120117

---

## 2. TÊN ĐỀ TÀI

**"AI Coding Assistant - Chatbot Hỗ Trợ Học Lập Trình"**

Chatbot AI giúp người dùng học lập trình, trả lời câu hỏi về code, giải thích thuật toán với **streaming response real-time**.

---

## 3. DANH SÁCH CÁC CHỨC NĂNG DỰ KIẾN VÀ TIMEFRAME DỰ KIẾN

Thời gian thực hiện: **Tuần 1** (từ ngày 18/11) -> **Tuần 6** (Hết ngày 17/12)

| Chức năng (Feature) | Chi tiết chức năng | Tuần dự kiến hoàn thành | Ghi chú & Liên kết Flowchart |
| :--- | :--- | :--- | :--- |
| **I. Thiết lập Hệ thống & Kết nối (Nền tảng)** | Khởi tạo server và kết nối API | 1-2 | **THIẾT LẬP KẾT NỐI VÀ PHIÊN CHAT** |
| 1. Khởi tạo kết nối với Ollama API | Setup OllamaClient, kết nối qua ngrok tunnel | 1-2 | Ô "Khởi tạo kết nối với AI server Ollama..." |
| 2. Tạo phiên chat mới | Khởi tạo ChatSession, lịch sử rỗng, hiển thị giao diện | 2 | Ô "Tạo phiên chat mới với lịch sử rỗng..." |
| --- | --- | --- | --- |
| **II. Xử lý Input & Quản lý Lệnh (Giao tiếp)** | Nhận và phân loại input từ người dùng | 2-3 | **VÒNG LẶP CHÍNH & XỬ LÝ LỆNH** |
| 3. Nhận input từ người dùng | Implement vòng lặp chính, getline, xử lý whitespace | 2 | Ô "Nhận input" (vòng lặp chính) |
| 4. Phân loại loại input | Logic phân biệt lệnh đặc biệt vs câu hỏi | 2-3 | Decision ◇ "Phân tích loại input nhận vào" |
| 5. Hệ thống lệnh đặc biệt | Xử lý /exit, /help, /clear, /history | 3 | Ô "Xử lí lệnh: /exit, /help, /clear, /history" |
| --- | --- | --- | --- |
| **III. Xử lý Câu hỏi & Gọi API (Nghiệp vụ chính)** | Chuẩn bị và gửi request đến AI | 3-4 | **GỬI YÊU CẦU VÀ NHẬN PHẢN HỒI** |
| 6. Lưu tin nhắn vào lịch sử | Implement Message class, lưu vào vector | 3 | Ô "Lưu câu hỏi vào lịch sử" |
| 7. Chuẩn bị dữ liệu gửi server | Build JSON: system prompt + lịch sử + câu hỏi | 3-4 | Ô "Chuẩn bị dữ liệu gửi về server..." |
| 8. Đóng gói JSON format | JSON serialization với nlohmann/json | 3-4 | Ô "Đóng gói thành JSON format" |
| 9. Gửi HTTP POST request | Sử dụng libcurl, setup headers, timeout | 4 | Ô "Gửi HTTP POS request tới Ollama API..." |
| --- | --- | --- | --- |
| **IV. Streaming Response (Tính năng nổi bật)** | Nhận và hiển thị real-time | 4-5 | **VÒNG LẶP STREAMING & HIỂN THỊ** |
| 10. Nhận streaming từ server | Implement StreamCallback function | 4 | Ô "Server nhận phản hồi dạng streaming" → "Chatbot nhận chunk..." |
| 11. Parse JSON chunk | Parse NDJSON trong callback | 4 | Ô "Parse JSON chunk nhận được từ callback" |
| 12. Xử lý lỗi parse | Try-catch, handle lỗi, bỏ qua chunk lỗi | 5 | Decision ◇ "Có lỗi khi parse JSON?" |
| 13. Trích xuất và hiển thị nội dung | Lấy content, cout real-time | 4-5 | Ô "Trích xuất nội dung và hiển thị..." |
| 14. Lưu câu trả lời vào lịch sử | Lưu full response vào vector | 5 | Ô "Lưu câu trả lời đầy đủ vào lịch sử" |
| --- | --- | --- | --- |
| **V. Hoàn thiện/Test/Deployment** | Testing, debug, optimize | 5-6 | **ĐẢM BẢO CHẤT LƯỢNG & TÀI LIỆU** |
| 15. Testing & Debug | Test từng chức năng, fix bugs | 5 | Test toàn bộ flowchart |
| 16. Documentation | Viết README, báo cáo | 6 | Hoàn thiện tài liệu dự án |


## 4. CHỨNG MINH KHẢ THI 
### 4.1 CHỨNG MINH BẰNG FLOWCHART

![Flowchart chứng minh khả thi](<Flowchart_POC.png>)

### 4.2 MÔ PHỎNG AI Ở LOCAL BẰNG CODE 
Biên dịch chương trình mô phỏng AI ở local với các chức năng đã được implement tối giản trước khi được chạy thông qua Ollama API
```Bash
$ g++ -std=c++23 demo_chat.cpp -lcurl -o ./out/app
```
```Bash
$ ./out/app
```
### 4.3 SERVER DÙNG CHO VIỆC THỰC HIỆN CHATBOT (DEMO)
Khởi tạo kết nối với Ollama API server (chạy trên Kaggle Notebook), sau đó expose server ra Internet để chatbot có thể truy cập từ máy local thông qua ngrok tunnel với đường dẫn

``` Bash
https://dionna-squarelike-centrically.ngrok-free.dev/

```
## 5. QUY TRÌNH LÀM VIỆC

Để dự án luôn ổn định, dễ kiểm soát và thuận tiện mở rộng sau này, cần phải áp dụng một quy trình rõ ràng.

### 5.1. QUẢN LÝ MÃ NGUỒN
Sử dụng **Git** và **GitHub** để quản lý phiên bản.

- **Repository:** Một repo duy nhất chứa toàn bộ mã nguồn.
- **Branching:**  
  - Nhánh `main` luôn giữ trạng thái ổn định.  
  - Mỗi tính năng mới được phát triển trên nhánh riêng `feature/...`.
- **Pull Request & tự review:**  
  Sau khi hoàn thành một tính năng, tạo Pull Request để kiểm tra lại:  
  - Kiểm tra logic hoạt động.  
  - Đảm bảo tuân thủ convention.  
  - Refactor nếu cần.  
  Việc này giúp mã sạch, có tổ chức và giảm thiểu lỗi.

### 5.2. CÁCH TỔ CHỨC 
Áp dụng kiến trúc **Layered Architecture**:

- **UI layer:** Xử lý giao diện, nhập/xuất dữ liệu.
- **BLL layer:** Chứa toàn bộ logic nghiệp vụ, OOP, thuật toán.
- **DAL layer:** Đọc/ghi dữ liệu (file, cơ sở dữ liệu...).

Mỗi tính năng được thực hiện theo thứ tự:
1. Xác định yêu cầu từ giao diện.  
2. Viết chức năng tương ứng ở BLL.  
3. Bổ sung xử lý dữ liệu ở DAL nếu cần.

Cách làm này giúp các phần kết nối rõ ràng, dễ bảo trì và mở rộng.

### 5.3. THEO DÕI TIẾN ĐỘ CÔNG VIỆC
Sử dụng **Kanban** (Trello hoặc GitHub Projects) để quản lý công việc:

- **To Do** – việc cần làm  
- **In Progress** – đang thực hiện  
- **In Review** – đã hoàn thành code, đang kiểm tra lại  
- **Done** – hoàn tất  

Cuối tuần, xem lại tiến độ và điều chỉnh kế hoạch nếu cần.

---

## 6. CÁCH TẠO MÃ NGUỒN CHẤT LƯỢNG

### 6.1. CODING CONVENTION
Áp dụng quy tắc rút gọn từ:
- C++ Core Guidelines  
- Google C++ Style Guide  
- Các nguyên tắc lập trình tốt từ giảng viên

#### 6.1.1. QUY TẮC ĐẶT TÊN
- **Class/Struct:** `PascalCase`
- **Hàm:** `camelCase`
- **Thuộc tính:** `_camelCase`
- **Biến cục bộ:** `camelCase`
- **Hằng số:** `ALL_UPPERCASE`  
- Tránh magic numbers.

#### 6.1.2. QUY TẮC ĐỊNH DẠNG
- Thụt lề 4 spaces (không dùng tab).  
- Dấu `{` đặt cuối dòng lệnh điều kiện hoặc hàm.  
- Luôn có khoảng trắng quanh toán tử và sau dấu phẩy.  
- Tránh biểu thức gây nhầm lẫn (vd: `a[i] = i++`).  
- Ưu tiên `if (ptr)` thay vì `if (ptr != nullptr)`.

#### 6.1.3. TỔ CHỨC FILE
- Tách riêng `.h` và `.cpp`.  
- Thứ tự include: STL → thư viện ngoài → file nội bộ.  
- Luôn dùng include guards.  
- Không dùng `using namespace std;`.

#### 6.1.4. TẠO COMMENT COMMENT
- Viết comment theo Doxygen cho class và hàm.  
- Chỉ comment **vì sao**, không comment **cái gì**.

#### 6.1.5. CÁC QUY TẮC KHÁC
- Dùng `nullptr` thay `NULL`.  
- Khai báo mỗi biến một dòng.  
- Tránh `std::endl`.  
- Có thể dùng `std::expected` thay `try/catch`.

---

## 6.2. NGUYÊN TẮC THIẾT KẾ

### 6.2.1. SOLID
Áp dụng đầy đủ 5 nguyên tắc để code dễ mở rộng và bảo trì:
- **SRP** – Mỗi class chỉ làm một việc.  
- **OCP** – Mở rộng dễ, ít sửa code cũ.  
- **LSP** – Lớp con thay thế được lớp cha.  
- **ISP** – Interface nhỏ, đúng mục đích.  
- **DIP** – Lớp cấp cao phụ thuộc abstraction, không phụ thuộc chi tiết.

### 6.2.2. KISS
Ưu tiên giải pháp đơn giản nhất có thể.

### 6.2.3. DRY
Không lặp lại logic – nếu thấy lặp, refactor ngay.

---

## 6.3. QUY TẮC TESTING

### 6.3.1. UNIT TEST
Sử dụng **Google Test** để kiểm tra từng class và hàm.  
Viết test song song với code để đảm bảo tính đúng đắn và giảm lỗi.

### 6.3.2. MANUAL TEST
Sau khi tích hợp các layer, chạy thử các kịch bản người dùng để kiểm tra toàn bộ hệ thống hoạt động như mong đợi.

---

## 6.4. KIẾN TRÚC MÃ NGUỒN
Áp dụng **Layered Architecture** với 3 lớp:

1. **UI (Presentation):** Giao diện người dùng.  
2. **BLL (Business Logic):** Xử lý nghiệp vụ, OOP, thuật toán.  
3. **DAL (Data Access):** Đọc/ghi dữ liệu.  

Kiến trúc này giúp mã rõ ràng, dễ test và dễ nâng cấp (ví dụ: từ file sang database).

---

## 6.5. DESIGN PATTERN

### 6.5.1. FACADE PATTERN
Một lớp trung gian che giấu độ phức tạp của hệ thống con, cung cấp API đơn giản cho các layer khác.

### 6.5.2. SIMPLE FACTORY
Tạo đối tượng phù hợp dựa trên input mà không để client biết chi tiết triển khai.

### 6.5.3. SINGLETON
Đảm bảo chỉ có một instance duy nhất của một lớp trong toàn bộ chương trình.